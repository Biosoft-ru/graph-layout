package ru.biosoft.graph;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Algorithm to build orthogonal paths for arbitrary arranged graph nodes.
 * <p/>
 * All paths are snapped to grid specified by <code>gridX</code> and <code>gridY</code>
 * parameters.
 * <p/>
 * Generally, path finding consists from 3 steps:
 * <ol>
 * <li> algorithm tries to draw all direct lines if it is possible using methods
 * {@see OrthogonalPathLayouter.createHorisontalLinePath} and {@see OrthogonalPathLayouter.createVerticalLinePath}.</li>
 * <li> create paths for self loops using {@link SelfLoopLayouter}</li>
 * <li> For other edges algorithm generates a set of possible paths
 * using {@link Face} and {@link OrthogonalPathFinder},
 * select best of them using {@link PathWeighter} and finally
 * tries to remove redundant points from the paths
 * using {@see OrthogonalPathLayouter.optimisePath} method.</li>
 * </ol>
 * <p/>
 * <p>Path set generation routine is following (see {@see OrthogonalPathLayouter.createPath} method for more details):
 * <ol>
 * <li> for <code>from</code> node algorithm generates a set of points where it can start the path.
 * This set of points is contained and generated by <code>Face</code> class;</li>
 * <li> for <code>to<code> node the similar set of points is generated.</li>
 * <li> all possible combinations between <code>from</code> and <code>to</code> faces are generated.
 * For example, if <code>from</code> face contains 4 points and <code>to</code> points
 * also contains 4 points, then 4*4 possible paths will be generated.
 * This initial paths will be generated by <c>OrthogonalPathFinder</c>.</li>
 * </ol>
 *
 * @see Face
 * @see OrthogonalPathFinder
 * @see PathWeighter
 */
public class OrthogonalPathLayouter extends AbstractLayouter
{
    protected static final Logger log = Logger.getLogger(OrthogonalPathLayouter.class.getName());

    public static enum Orientation
    {
        LEFT, RIGHT, TOP, BOTTOM, NONE;

        public static final String LEFT_NAME = "left";
        public static final String RIGHT_NAME = "right";
        public static final String TOP_NAME = "top";
        public static final String BOTTOM_NAME = "bottom";
        public static final String NONE_NAME = "none";

        /**
         * Get {@link String} for current object value
         */
        @Override
        public String toString()
        {
            switch( this )
            {
                case LEFT:
                    return LEFT_NAME;
                case RIGHT:
                    return RIGHT_NAME;
                case TOP:
                    return TOP_NAME;
                case BOTTOM:
                    return BOTTOM_NAME;
                case NONE:
                default:
                    return NONE_NAME;
            }
        }

        /**
         * Get {@link PortOrientation} object by {@link String}
         */
        public static Orientation fromString(String value)
        {
            if( value != null )
            {
                if( value.equals(LEFT_NAME) )
                {
                    return LEFT;
                }
                else if( value.equals(RIGHT_NAME) )
                {
                    return RIGHT;
                }
                else if( value.equals(TOP_NAME) )
                {
                    return TOP;
                }
                else if( value.equals(BOTTOM_NAME) )
                {
                    return BOTTOM;
                }
            }
            return NONE;//default orientation
        }

        public static String[] getAvailableTags()
        {
            Object[] vals = values();
            String[] result = new String[vals.length];
            for( int i = 0; i < vals.length; i++ )
            {
                result[i] = vals[i].toString();
            }
            return result;
        }
        
        public Orientation clockwise()
        {
            switch( this )
            {
                case TOP:
                    return RIGHT;
                case RIGHT:
                    return BOTTOM;
                case BOTTOM:
                    return LEFT;
                default:
                    return TOP;
            }
        }
    }

    Orientation orientation = Orientation.NONE;
    public String getOrientation()
    {
        return orientation.toString();
    }
    public void setOrientation(String text)
    {
        orientation = Orientation.fromString(text);
    }

    static class Shift
    {
        int first;
        int second;

        public Shift(int first, int second)
        {
            this.first = first;
            this.second = second;
        }
    }

    /**
     * Diameter of smooth
     */
    public static final double RADIUS = 5.0;

    /**
     * Minimal size of the node
     */
    public static final int MINIMAL_SIZE = 15;//24;

    public static final String OLD_WIDTH_ATTR = "oldWidth";
    public static final String OLD_HEIGHT_ATTR = "oldHeight";


    private boolean smoothEdges = false;
    public boolean isSmoothEdges()
    {
        return smoothEdges;
    }
    public void setSmoothEdges(boolean smoothEdges)
    {
        this.smoothEdges = smoothEdges;
    }

    /**
     * Grid x step.
     */
    public int gridX = 10;
    public int getGridX()
    {
        return gridX;
    }
    public void setGridX(int gridX)
    {
        this.gridX = gridX;
    }

    /**
     * Grid Y step.
     */
    public int gridY = 10;
    public int getGridY()
    {
        return gridY;
    }

    public void setGridY(int gridY)
    {
        this.gridY = gridY;
    }

    private int iterationMax = 7;
    public int getIterationMax()
    {
        return iterationMax;
    }
    public void setIterationMax(int iterationMax)
    {
        this.iterationMax = iterationMax;
    }

    private int iterationK = 3;
    public int getIterationK()
    {
        return iterationMax;
    }
    public void setIterationK(int iterationK)
    {
        this.iterationK = iterationK;
    }

    /**
     * If true then from one point only one edge can starts or ends
     */
    private boolean oneEdgeToPoint = false;

    public void setOneEdgeToPoint(boolean oneEdgeToPoint)
    {
        this.oneEdgeToPoint = oneEdgeToPoint;
    }

    public void setPortExchangeMax(int portExchangeMax)
    {
        this.portExchangeMax = portExchangeMax;
    }

    private int portExchangeMax = 5;

    private final SelfLoopLayouter selfLoopLayouter = new SelfLoopLayouter();

    private final DiagonalPathLayouter stubPathLayouter = new DiagonalPathLayouter();

    private final Shift[] shifts;

    private final List<Integer> intersections = new ArrayList<>();

    public OrthogonalPathLayouter(int gridX, int gridY)
    {
        this();
        this.gridX = gridX;
        this.gridY = gridY;
    }

    public OrthogonalPathLayouter()
    {
        shifts = new Shift[8];
        shifts[0] = new Shift( -1, 0);
        shifts[1] = new Shift(1, 0);
        shifts[2] = new Shift( -2, 0);
        shifts[3] = new Shift(2, 0);
        shifts[4] = new Shift(0, -1);
        shifts[5] = new Shift(0, -2);
        shifts[6] = new Shift(0, 2);
        shifts[7] = new Shift(0, 1);
    }

    @Override
    public void layoutNodes(Graph graph, LayoutJobControl jobControl)
    {
        //do not layout nodes
    }

    @Override
    public void layoutEdges(Graph graph, LayoutJobControl lJC)
    {
        if( smoothEdges )
        {
            preprocess(graph);
            doLayoutEdges(graph, lJC);
            postproces(graph);
        }
        else
        {
            doLayoutEdges(graph, lJC);
        }
    }

    @Override
    public void layoutPath(Graph graph, Edge edge, LayoutJobControl lJC)
    {
    	if (edge.fixed)
    		return;
        if( smoothEdges )
        {
            preprocess(graph);
            doLayoutPath(graph, edge, lJC);
            postproces(graph);
        }
        else
        {
            doLayoutPath(graph, edge, lJC);
        }
    }


    public void doLayoutEdges(Graph graph, LayoutJobControl jobControl)
    {
        // 0th iteration delete current paths
        for( Edge edge : graph.edgeList )
        {
			if (!edge.fixed)
				edge.setPath(null);
        }

        // 1st iteration - direct lines
        for( Edge edge : graph.edgeList )
        {
			if (edge.fixed)
				continue;
            //if ( edge.getPath() == null )
            //    continue;

            if( edge.getFrom() != edge.getTo() )
            {
                if( createHorisontalLinePath(graph, edge) || createVerticalLinePath(graph, edge) )
                {
                    int weight = pathWeighter.calcPathWeight(graph, edge.getPath(), PathWeighter.edgeIntersectionPenalty);
                    if( weight < PathWeighter.edgeIntersectionPenalty )
                        continue;
                }

                edge.setPath(null);
            }
        }
        
        // 2nd iteration - layout loops
        selfLoopLayouter.doLayout(graph, pathWeighter);

        // 3rd iteration - lines with bends and parallel edges
        for( Edge edge : graph.edgeList )
            if( !edge.fixed && edge.getPath() == null )
                createPath(graph, edge, pathWeighter);

        // change ports for edges
        for( int i = 0; i < portExchangeMax; i++ )
        {
            if( !refinePorts(graph, pathWeighter) )
            {
                break;
            }
        }

        
        // refine line paths
        refinePaths(graph, pathWeighter);
        
        // fix self-intersections
        for( Edge edge : graph.edgeList )
            if( !edge.fixed && edge.getPath() != null )
            {
                edge.getPath().removeSelfIntersections();
                //                if (!edge.getFrom().toString().equalsIgnoreCase( "N:waifParameters") || !edge.getTo().toString().equalsIgnoreCase( "N:import"))
                //                    continue;
                edge.getPath().removeUTurn(graph);
                
            }

        
        for( Edge edge : graph.edgeList )
            if( !edge.fixed && edge.getPath() != null )
            {
                Path p = edge.getPath();
                Point start = edge.getFrom().findPort(p.xpoints[0], p.ypoints[0], edge);
                Point finish = edge.getTo().findPort(p.xpoints[p.npoints - 1], p.ypoints[p.npoints - 1], edge);

                p.xpoints[0] = start.x;
                p.ypoints[0] = start.y;

                p.xpoints[p.npoints - 1] = finish.x;
                p.ypoints[p.npoints - 1] = finish.y;

            }
    }

    @Override
    public int estimate(Graph graph, int what)
    {
        return 0;
    }

    @Override
    public LayouterInfo getInfo()
    {
        return new LayouterInfoSupport(true, false, false, false, false, false);
    }

    //-----------------------------------------------------------------------------
    public void doLayoutPath(Graph graph, Edge edge, LayoutJobControl jobControl)
    {
        edge.setPath(null);

        if( edge.getFrom() == edge.getTo() )
        {
            selfLoopLayouter.layoutPath(graph, edge, pathWeighter);
            return;
        }

        Path straightPath = null;
        int straightWeight = Integer.MAX_VALUE;

        if( createHorisontalLinePath(graph, edge) || createVerticalLinePath(graph, edge) )
        {
            straightWeight = pathWeighter.calcPathWeight(graph, edge.getPath(), PathWeighter.edgeIntersectionPenalty);
            if( straightWeight < PathWeighter.edgeIntersectionPenalty )
                return;

            straightPath = edge.getPath();
        }
        edge.setPath(null);

        // check with one line path with intersections
        if( createPath(graph, edge, pathWeighter) > straightWeight )
            edge.setPath(straightPath);

        // refine line path
        refinePaths(graph, edge, pathWeighter);
    }

    public boolean createHorisontalLinePath(Graph graph, Edge edge)
    {
        if( orientation == Orientation.TOP || orientation == Orientation.BOTTOM )
            return false;

        Node from = edge.getFrom();
        Node to = edge.getTo();

        Set<Node> exclusions = new HashSet<>();
        Node comaprtmentFrom = Util.getCompartment( from, graph );
        Node compartmentTo = Util.getCompartment( to, graph );
        if (comaprtmentFrom != null)
            exclusions.add( comaprtmentFrom );
        if (compartmentTo != null)
            exclusions.add( compartmentTo );
        
        int y1 = Math.max(from.y, to.y);
        int y2 = Math.min(from.y + from.height, to.y + to.height);
        int dy = y2 - y1;

        int y = y1 + dy / 2 / gridY * gridY;
        if( y < y1 - 3 )
            return false;

        int x1, x2;
        if( from.x < to.x )
        {
            x1 = from.x + from.width;
            x2 = to.x;
        }
        else
        {
            x1 = from.x;
            x2 = to.x + to.width;
        }

        Point newFrom1 = from.findPort(x1, y, edge);
        Point newTo1 = to.findPort(x2, newFrom1.y, edge);

        Point newTo2 = to.findPort(x2, y, edge);
        Point newFrom2 = from.findPort(x1, newTo2.y, edge);

        // check whether FindPort allows to use this edge at all
        if( !createPath(edge, x1, y, x2, y, false) && !createPath(edge, newFrom1.x, newFrom1.y, newTo1.x, newTo1.y, false)
                && !createPath(edge, newFrom2.x, newFrom2.y, newTo2.x, newTo2.y, false) )
            return false;

        Node node = graph.getIntersectedNode(x1, y - gridY, x2, y + gridY, exclusions);
        if( node == null )
            return true; // path already created

        // some optimization - from the intersected node bounds we try to define
        // whether we can draw the line at all
        if( node.y - y1 < gridY + 1 && y2 - node.y - node.height < gridY + 1 )
            return false;

        int yk, k = dy / gridY;
        if( k == 1 )
        {
            yk = y + gridY;
            if( graph.getIntersectedNode(x1, yk - gridY, x2, yk + gridY, exclusions) == null )
                if( createPath(edge, x1, yk, x2, yk, false) )
                    return true;
        }

        k /= 2;
        for( int i = 1; i < k; i++ )
        {
            yk = y + i * gridY;
            if( graph.getIntersectedNode(x1, yk - gridY, x2, yk + gridY, exclusions) == null )
                if( createPath(edge, x1, yk, x2, yk, false) )
                    return true;

            yk = y - i * gridY;
            if( graph.getIntersectedNode(x1, yk - gridY, x2, yk + gridY, exclusions) == null )
                if( createPath(edge, x1, yk, x2, yk, false) )
                    return true;
        }

        return false;
    }
    public boolean createVerticalLinePath(Graph graph, Edge edge)
    {
        if( orientation == Orientation.LEFT || orientation == Orientation.RIGHT )
            return false;

        Node from = edge.getFrom();
        Node to = edge.getTo();

        Set<Node> exclusions = Util.getCompartments( edge, graph );
        
        int x1 = Math.max(from.x, to.x);
        int x2 = Math.min(from.x + from.width, to.x + to.width);
        int dx = x2 - x1;

        int x = x1 + dx / 2 / gridX * gridX;
        if( x < x1 - 3 )
            return false;

        int y1, y2;
        if( from.y < to.y )
        {
            y1 = from.y + from.height;
            y2 = to.y;
        }
        else
        {
            y1 = from.y;
            y2 = to.y + to.height;
        }

        Point newFrom1 = from.findPort(x, y1, edge);
        Point newTo1 = to.findPort(newFrom1.x, y2, edge);

        Point newTo2 = to.findPort(x, y2, edge);
        Point newFrom2 = from.findPort(newTo2.x, y1, edge);

        // check whether FindPort allows to use this edge at all
        if( !createPath(edge, x, y1, x, y2, true) && !createPath(edge, newFrom1.x, newFrom1.y, newTo1.x, newTo1.y, true)
                && !createPath(edge, newFrom2.x, newFrom2.y, newTo2.x, newTo2.y, true) )
            return false;

        Node node = graph.getIntersectedNode(x - gridX, y1, x + gridX, y2, exclusions);
        if( node == null )
            return true; // path already created

        // some optimization - from the intersected node bounds we try to define
        // whether we can draw the line at all
        if( node.x - x1 < gridX + 1 && x2 - node.x - node.width < gridX + 1 )
            return false;

        int xk, k = dx / gridX;
        if( k == 1 )
        {
            xk = x + gridX;
            if( graph.getIntersectedNode(y1, xk - gridX, x2, xk + gridX, exclusions) == null )
                if( createPath(edge, y1, xk, y2, xk, false) )
                    return true;
        }

        k /= 2;
        for( int i = 1; i < k; i++ )
        {
            xk = x + i * gridX;
            if( graph.getIntersectedNode(xk - gridX, y1, xk + gridX, y2, exclusions) == null )
                if( createPath(edge, xk, y1, xk, y2, true) )
                    return true;

            xk = x - i * gridX;
            if( graph.getIntersectedNode(xk - gridX, y1, xk + gridX, y2, exclusions) == null )
                if( createPath(edge, xk, y1, xk, y2, true) )
                    return true;
        }

        return false;
    }

    private boolean createPath(Edge edge, int x1, int y1, int x2, int y2, boolean isVertical)
    {
        edge.setPath(null); // clear line path to not confuse port finder

        // TODO: FIX portFinder, add graph param
        Point pFrom = edge.getFrom().findPort(x1, y1, edge);
        Point pTo = edge.getTo().findPort(x2, y2, edge);

        Node from = edge.getFrom();
        Node to = edge.getTo();

        // check whether new line is straight line and belongs to the required edge
        if( isVertical )
        {
            if( pFrom.x != pTo.x || pFrom.x < from.x || pFrom.x > from.x + from.width || pTo.x < to.x || pTo.x > to.x + to.width
                    || Math.abs(pFrom.y - y1) > from.width / 2 || Math.abs(pTo.y - y2) > to.width / 2 )
                return false;
        }
        else
        {
            if( pFrom.y != pTo.y || pFrom.y < from.y || pFrom.y > from.y + from.height || pTo.y < to.y || pTo.y > to.y + to.height
                    || Math.abs(pFrom.x - x1) > from.height / 2 || Math.abs(pTo.x - x2) > to.height / 2 )
                return false;
        }

        edge.setPath(new Path(new int[]{pFrom.x, pTo.x}, new int[]{pFrom.y, pTo.y}, 2 ));
        return true;
    }

    // returns path weight
    private int createPath(Graph graph, Edge edge, PathWeighter pathWeighter)
    {
        int weight = createPath(graph, edge, iterationMax, pathWeighter);

        if( edge.getPath() == null )
        {
            log.log( Level.FINE, "can not find path for edge: " + edge.toString() );
            stubPathLayouter.layoutPath(graph, edge, pathWeighter);
        }

        return weight;
    }

    // returns path weight
    private int createPath(Graph graph, Edge edge, int iterMax, PathWeighter pathWeighter)
    {
        int i;
        Node from = edge.getFrom();
        Node to = edge.getTo();
        Set<Node> exc = Util.getCompartments( edge, graph );
        
        // generate a set of possible paths
        Face fromFace = new Face(graph, from, edge, gridX, gridY, oneEdgeToPoint, orientation);
        Face toFace = new Face(graph, to, edge, gridX, gridY, oneEdgeToPoint, orientation);

        int fromCount = fromFace.size();
        int toCount = toFace.size();
        int totalCount = fromCount * toCount;

        OrthogonalPathFinder[] finders = new OrthogonalPathFinder[fromCount * toCount];
        for( i = 0; i < fromCount; i++ )
        {
            Point pFrom = fromFace.startPoints.get(fromFace.points.get(i));
            for( int j = 0; j < toCount; j++ )
            {
                Point pTo = toFace.startPoints.get(toFace.points.get(j));
                int toX = pTo.x;
                int toY = pTo.y;

                finders[i * toCount + j] = new OrthogonalPathFinder(graph, exc, pFrom.x, pFrom.y, toX, toY, gridX, gridY);
            }
        }

        // main cycle - find all paths with maximum bends number n
        int n = iterMax;
        while( n > 0 )
        {
            for( int k = 0; k < totalCount; k++ )
            {
                finders[k].nextStep();
                if( finders[k].hasSolution() && n > iterationK )
                    n = iterationK;
            }

            n--;
        }

        // add start and end point to the paths
        List<Path> pathList = new ArrayList<>();
        for( i = 0; i < fromCount; i++ )
        {
            Point pFrom = fromFace.startPoints.get(fromFace.points.get(i));
            for( int j = 0; j < toCount; j++ )
            {
                Point pTo = toFace.startPoints.get(toFace.points.get(j));
                int toXs = pTo.x;
                int toYs = pTo.y;

                List<Path> paths = finders[i * toCount + j].getSolutions();
                if( paths != null )
                    for( Path path : paths )
                        pathList.add(createPath(pFrom.x, pFrom.y, path, toXs, toYs));
            }
        }

        // main cycle to optimize and select the best from them
        Path bestPath = null;
        int bestWeight = Integer.MAX_VALUE;
        for( i = 0; i < pathList.size(); i++ )
        {
            Path path = pathList.get(i);
            optimisePath(path);

            int weight = pathWeighter.calcPathWeight(graph, path, bestWeight);
            if( weight < bestWeight )
            {
                bestPath = path;
                bestWeight = weight;
            }
        }

        //simplify path
        bestPath = simplifyPath(graph, bestPath, bestWeight, pathWeighter);

        if( bestPath != null )
        {
            edge.setPath(bestPath);
            return pathWeighter.calcPathWeight(graph, bestPath, bestWeight);
        }

        return bestWeight;
    }

    private Path simplifyPath(Graph graph, Path bestPath, int bestWeight, PathWeighter pathWeighter)
    {
        Path path = bestPath;
        if( path != null && path.npoints >= 5 )
        {
            boolean needMoreIteration = true;
            while( needMoreIteration )
            {
                needMoreIteration = false;
                for( int i = 0; i < path.npoints - 4; i++ )
                {
                    Path newPath = createSimplifyPath(graph, path, i);
                    if( newPath != null )
                    {
                        int weight = pathWeighter.calcPathWeight(graph, newPath, bestWeight);
                        if( weight <= bestWeight )
                        {
                            path = newPath;
                            bestWeight = weight;
                            needMoreIteration = true;
                            break;
                        }
                    }
                }
            }
        }
        return path;
    }

    private Path createSimplifyPath(Graph graph, Path basePath, int pos)
    {
        Path newPath = new Path();
        for( int i = 0; i < pos + 1; i++ )
        {
            newPath.addPoint(basePath.xpoints[i], basePath.ypoints[i]);
        }
        Point newPoint = null;
        if( ( basePath.ypoints[pos] == basePath.ypoints[pos + 1] ) && ( basePath.xpoints[pos + 3] == basePath.xpoints[pos + 4] ) )
        {
            newPoint = new Point(basePath.xpoints[pos + 3], basePath.ypoints[pos]);
        }
        else if( ( basePath.xpoints[pos] == basePath.xpoints[pos + 1] ) && ( basePath.ypoints[pos + 3] == basePath.ypoints[pos + 4] ) )
        {
            newPoint = new Point(basePath.xpoints[pos], basePath.ypoints[pos + 3]);
        }
        else
        {
            return null;
        }
        if( Path.checkIntersections(graph, basePath.xpoints[pos], basePath.ypoints[pos], newPoint.x, newPoint.y)
                || Path.checkIntersections(graph, newPoint.x, newPoint.y, basePath.xpoints[pos + 4], basePath.ypoints[pos + 4]) )
        {
            //new path will intersect with some nodes and should be ignored
            return null;
        }
        newPath.addPoint(newPoint.x, newPoint.y);
        for( int i = pos + 4; i < basePath.npoints; i++ )
        {
            newPath.addPoint(basePath.xpoints[i], basePath.ypoints[i]);
        }

        return newPath;
    }

    private void optimisePath(Path path)
    {
        boolean optimise = false;
        for( int i = 0; i < path.npoints - 2; i++ )
        {
            if( ( path.xpoints[i] == path.xpoints[i + 1] && path.xpoints[i + 1] == path.xpoints[i + 2] )
                    || ( path.ypoints[i] == path.ypoints[i + 1] && path.ypoints[i + 1] == path.ypoints[i + 2] ) )
            {
                path.removePoint(i + 1);
                optimise = true;
                break;
            }
        }

        if( optimise )
            optimisePath(path);
    }

    private Path createPath(int xFrom, int yFrom, Path subPath, int xTo, int yTo)
    {
        Path path = new Path();

        path.addPoint(xFrom, yFrom);

        for( int i = 0; i < subPath.npoints; i++ )
            path.addPoint(subPath.xpoints[i], subPath.ypoints[i]);

        path.addPoint(xTo, yTo);

        return path;
    }

    private void refinePaths(Graph graph, PathWeighter pathWeighter)
    {
        int edgeCount = graph.edgeCount();
        int k1, k2;

        // find edges with confluences and intersection
        for( k1 = 0; k1 < edgeCount; k1++ )
        {
            Edge e1 = graph.edgeList.get(k1);
            if (e1.fixed)
            	continue;
            for( k2 = k1 + 1; k2 < edgeCount; k2++ )
            {
                Edge e2 = graph.edgeList.get(k2);
                if (e2.fixed)
                	continue;
                refine(graph, e1, e2, pathWeighter);
            }
        }
    }

    private void refinePaths(Graph graph, Edge e, PathWeighter pathWeighter)
    {
        int edgeCount = graph.edgeCount();
        // find edges with confluences and intersection
        for( int i = 1; i < edgeCount; i++ )
        {
            Edge e2 = graph.edgeList.get(i);
            if( !e.equals(e2) )
                refine(graph, e, e2, pathWeighter);
        }
    }

    private void refine(Graph graph, Edge e1, Edge e2, PathWeighter pathWeighter)
    {
        // if some edge has no path - it is nothing to refine
        if( e1.getPath() == null || e2.getPath() == null )
            return;

        // optimize confluences
        if( calcIntersections(e1, e2) )
        {
            int s1 = intersections.get(0);
            int s2 = intersections.get(1);

            Path p1 = e1.getPath();
            Path p2 = e2.getPath();

            Set<Node> exc1 = Util.getCompartments( e1, graph );
            Set<Node> exc2 = Util.getCompartments( e2, graph );
            
            boolean vertical = ( p1.xpoints[s1] == p1.xpoints[s1 + 1] );
            int delta = vertical ? gridX : gridY;
            boolean first = true;
            int position = 0;
            int bestWeight = calcSegmentWeight(graph, vertical, Integer.MAX_VALUE, p1, s1, 0, p2, s2, 0, pathWeighter, exc1, exc2);
            int weight;

            for( Shift shift : shifts )
            {
                weight = calcSegmentWeight(graph, vertical, bestWeight, p1, s1, delta * shift.first, p2, s2, delta * shift.second,
                        pathWeighter, exc1, exc2);

                if( weight < bestWeight )
                {
                    bestWeight = weight;
                    first = shift.first != 0;
                    position = first ? delta * shift.first : delta * shift.second;
                }
            }

            // refine
            Path p = first ? p1 : p2;
            int s = first ? s1 : s2;
            if( vertical )
            {
                p.xpoints[s] += position;
                p.xpoints[s + 1] += position;
            }
            else
            {
                p.ypoints[s] += position;
                p.ypoints[s + 1] += position;
            }
        }
    }

    /**
     * Try to change ports for every two intersected paths in one node
     *
     * @return true if better paths was founded
     */
    private boolean refinePorts(Graph graph, PathWeighter pathWeighter)
    {
        int edgeCount = graph.edgeCount();
        int k1, k2;
        boolean result = false;

        // find edges with intersection and common node
        for( k1 = 0; k1 < edgeCount; k1++ )
        {
            Edge e1 = graph.edgeList.get(k1);
            if (e1.fixed)
            	continue;

            for( k2 = k1 + 1; k2 < edgeCount; k2++ )
            {
                Edge e2 = graph.edgeList.get(k2);

                if (e2.fixed)
                	continue;

                if( e1.getPath() != null && e2.getPath() != null )
                {
                    if( ( e1.getFrom() == e2.getFrom() ) || ( e1.getFrom() == e2.getTo() ) || ( e1.getTo() == e2.getFrom() )
                            || ( e1.getTo() == e2.getTo() ) )
                    {
                        if( isIntersected(e1, e2) )
                        {
                            if( refinePort(graph, e1, e2, pathWeighter) )
                            {
                                result = true;
                            }
                        }
                    }
                }
            }
        }

        return result;
    }

    /**
     * Try to change ports for pair of edge
     *
     * @return true if better paths were found
     */
    private boolean refinePort(Graph graph, Edge e1, Edge e2, PathWeighter pathWeighter)
    {
        int currentWeight = pathWeighter.calcPathWeight(graph, e1.getPath(), Integer.MAX_VALUE);
        currentWeight += pathWeighter.calcPathWeight(graph, e2.getPath(), Integer.MAX_VALUE);

        Path oldPath1 = e1.getPath();
        Path oldPath2 = e2.getPath();

        Point input1 = new Point();
        Point output1 = new Point();
        Point input2 = new Point();
        Point output2 = new Point();

        if( e1.getFrom() == e2.getFrom() )
        {
            input1.x = oldPath2.xpoints[0];
            input1.y = oldPath2.ypoints[0];
            input2.x = oldPath1.xpoints[0];
            input2.y = oldPath1.ypoints[0];
            output1.x = oldPath1.xpoints[oldPath1.npoints - 1];
            output1.y = oldPath1.ypoints[oldPath1.npoints - 1];
            output2.x = oldPath2.xpoints[oldPath2.npoints - 1];
            output2.y = oldPath2.ypoints[oldPath2.npoints - 1];
        }
        else if( e1.getFrom() == e2.getTo() )
        {
            input1.x = oldPath2.xpoints[oldPath2.npoints - 1];
            input1.y = oldPath2.ypoints[oldPath2.npoints - 1];
            input2.x = oldPath2.xpoints[0];
            input2.y = oldPath2.ypoints[0];
            output1.x = oldPath1.xpoints[oldPath1.npoints - 1];
            output1.y = oldPath1.ypoints[oldPath1.npoints - 1];
            output2.x = oldPath1.xpoints[0];
            output2.y = oldPath1.ypoints[0];
        }
        else if( e1.getTo() == e2.getFrom() )
        {
            input1.x = oldPath1.xpoints[0];
            input1.y = oldPath1.ypoints[0];
            input2.x = oldPath1.xpoints[oldPath1.npoints - 1];
            input2.y = oldPath1.ypoints[oldPath1.npoints - 1];
            output1.x = oldPath2.xpoints[0];
            output1.y = oldPath2.ypoints[0];
            output2.x = oldPath2.xpoints[oldPath2.npoints - 1];
            output2.y = oldPath2.ypoints[oldPath2.npoints - 1];
        }
        else if( e1.getTo() == e2.getTo() )
        {
            input1.x = oldPath1.xpoints[0];
            input1.y = oldPath1.ypoints[0];
            input2.x = oldPath2.xpoints[0];
            input2.y = oldPath2.ypoints[0];
            output1.x = oldPath2.xpoints[oldPath2.npoints - 1];
            output1.y = oldPath2.ypoints[oldPath2.npoints - 1];
            output2.x = oldPath1.xpoints[oldPath1.npoints - 1];
            output2.y = oldPath1.ypoints[oldPath1.npoints - 1];
        }

        input1 = e1.getFrom().findPort(input1.x, input1.y, e1);
        output1 = e1.getTo().findPort(output1.x, output1.y, e1);
        input2 = e2.getFrom().findPort(input2.x, input2.y, e2);
        output2 = e2.getTo().findPort(output2.x, output2.y, e2);
        
        Set<Node> exc1 = Util.getCompartments( e1, graph );
        OrthogonalPathFinder finderE1 = new OrthogonalPathFinder(graph, exc1, input1.x, input1.y, output1.x, output1.y, gridX, gridY);
        for( int i = 0; i < iterationMax; i++ )
        {
            finderE1.nextStep();
            if( finderE1.hasSolution() )
                break;
        }
        
        Set<Node> exc2 = Util.getCompartments( e2, graph );
        OrthogonalPathFinder finderE2 = new OrthogonalPathFinder(graph, exc2, input2.x, input2.y, output2.x, output2.y, gridX, gridY);
        for( int i = 0; i < iterationMax; i++ )
        {
            finderE2.nextStep();
            if( finderE2.hasSolution() )
                break;
        }
        if( finderE1.hasSolution() && finderE2.hasSolution() )
        {
            Path newPathE1 = finderE1.getSolutions().get(0);
            optimisePath(newPathE1);
            newPathE1 = simplifyPath(graph, newPathE1, pathWeighter.calcPathWeight(graph, newPathE1, Integer.MAX_VALUE), pathWeighter);
            Path newPathE2 = finderE2.getSolutions().get(0);
            optimisePath(newPathE2);
            newPathE2 = simplifyPath(graph, newPathE2, pathWeighter.calcPathWeight(graph, newPathE2, Integer.MAX_VALUE), pathWeighter);
            e1.setPath(null);
            e2.setPath(null);
            int newWeight = pathWeighter.calcPathWeight(graph, newPathE1, currentWeight);
            newWeight += pathWeighter.calcPathWeight(graph, newPathE2, currentWeight);
            if( newWeight < currentWeight )
            {
                e1.setPath(newPathE1);
                e2.setPath(newPathE2);
                return true;
            }
            else
            {
                e1.setPath(oldPath1);
                e2.setPath(oldPath2);
            }
        }
        return false;
    }

    private int calcSegmentWeight(Graph graph, boolean vertical, int maxWeight, Path p1, int s1, int shift1, Path p2, int s2, int shift2,
            PathWeighter pathWeighter, Set<Node> exc1, Set<Node> exc2)
    {
        int weight = 0;

        // ignore edge attachment points
        if( ( shift1 != 0 && ( s1 == 0 || s1 == p1.npoints - 1 ) ) || ( shift2 != 0 && ( s2 == 0 || s2 == p2.npoints - 1 ) ) )
            return Integer.MAX_VALUE;

        weight += pathWeighter.calcLineWeight(graph, p1.xpoints[s1] + ( vertical ? shift1 : 0 ),
                p1.ypoints[s1] + ( vertical ? 0 : shift1 ), p1.xpoints[s1 + 1] + ( vertical ? shift1 : 0 ), p1.ypoints[s1 + 1]
                        + ( vertical ? 0 : shift1 ), maxWeight, exc1);

        weight += pathWeighter.calcLineWeight(graph, p2.xpoints[s2] + ( vertical ? shift2 : 0 ),
                p2.ypoints[s2] + ( vertical ? 0 : shift2 ), p2.xpoints[s2 + 1] + ( vertical ? shift2 : 0 ), p2.ypoints[s2 + 1]
                        + ( vertical ? 0 : shift2 ), maxWeight, exc2);

        return weight;
    }

    private boolean calcIntersections(Edge e1, Edge e2)
    {
        intersections.clear();

        boolean confluences = false;
        Path path1 = e1.getPath();
        Path path2 = e2.getPath();
        int i, j, tx, ty, tw, th, // edge 1
        rx, ry, rw, rh; // edge 2

        for( i = 0; i < path1.npoints - 1; i++ )
        {
            tx = Math.min(path1.xpoints[i], path1.xpoints[i + 1]) - 1;
            ty = Math.min(path1.ypoints[i], path1.ypoints[i + 1]) - 1;
            tw = Math.max(path1.xpoints[i], path1.xpoints[i + 1]) + 1;
            th = Math.max(path1.ypoints[i], path1.ypoints[i + 1]) + 1;

            for( j = 0; j < path2.npoints - 1; j++ )
            {
                rx = Math.min(path2.xpoints[j], path2.xpoints[j + 1]) - 1;
                ry = Math.min(path2.ypoints[j], path2.ypoints[j + 1]) - 1;
                rw = Math.max(path2.xpoints[j], path2.xpoints[j + 1]) + 1;
                rh = Math.max(path2.ypoints[j], path2.ypoints[j + 1]) + 1;

                //  overflow || intersect
                if( ( rw < rx || rw > tx ) && ( rh < ry || rh > ty ) && ( tw < tx || tw > rx ) && ( th < ty || th > ry ) )
                {
                    if( ( rx == tx && rw - rx == 2 && tw - tx == 2 ) || ( ry == ty && rh - ry == 2 && th - ty == 2 ) )
                    {
                        intersections.add(i);
                        intersections.add(j);
                        confluences = true;
                        intersections.add(1);
                    }
                }
            }
        }

        return confluences;
    }

    private boolean isIntersected(Edge e1, Edge e2)
    {
        Path path1 = e1.getPath();
        Path path2 = e2.getPath();
        int i, j, tx, ty, tw, th, // edge 1
        rx, ry, rw, rh; // edge 2

        for( i = 0; i < path1.npoints - 1; i++ )
        {
            tx = Math.min(path1.xpoints[i], path1.xpoints[i + 1]) - 1;
            ty = Math.min(path1.ypoints[i], path1.ypoints[i + 1]) - 1;
            tw = Math.abs(path1.xpoints[i] - path1.xpoints[i + 1]) + 1;
            th = Math.abs(path1.ypoints[i] - path1.ypoints[i + 1]) + 1;

            Rectangle r1 = new Rectangle(tx, ty, tw, th);
            for( j = 0; j < path2.npoints - 1; j++ )
            {
                rx = Math.min(path2.xpoints[j], path2.xpoints[j + 1]) - 1;
                ry = Math.min(path2.ypoints[j], path2.ypoints[j + 1]) - 1;
                rw = Math.abs(path2.xpoints[j] - path2.xpoints[j + 1]) + 1;
                rh = Math.abs(path2.ypoints[j] - path2.ypoints[j + 1]) + 1;

                if( r1.intersects(new Rectangle(rx, ry, rw, rh)) )
                {
                    return true;
                }
            }
        }

        return false;
    }



    @Override
    public void doLayout(Graph graph, LayoutJobControl lJC)
    {
        //only edge layout
        layoutEdges(graph, lJC);
    }

    /**
     * Actions before layout
     */
    protected void preprocess(Graph graph)
    {
        resizeNodes(graph);
    }

    /**
     * Actions after layout
     */
    protected void postproces(Graph graph)
    {
        restoreNodeSize(graph);
        smoothEdges(graph);
    }

    protected void resizeNodes(Graph graph)
    {
        Iterator<Node> iter = graph.nodeIterator();
        while( iter.hasNext() )
        {
            Node node = iter.next();
            if( node.width < MINIMAL_SIZE )
            {
                node.setAttribute(OLD_WIDTH_ATTR, Integer.toString(node.width));
                node.x -= ( MINIMAL_SIZE - node.width ) / 2;
                node.width = MINIMAL_SIZE;
            }
            if( node.height < MINIMAL_SIZE )
            {
                node.setAttribute(OLD_HEIGHT_ATTR, Integer.toString(node.height));
                node.y -= ( MINIMAL_SIZE - node.height ) / 2;
                node.height = MINIMAL_SIZE;
            }
        }
    }

    protected void restoreNodeSize(Graph graph)
    {
        Iterator<Node> iter = graph.nodeIterator();
        while( iter.hasNext() )
        {
            Node node = iter.next();
            String width = node.getAttribute(OLD_WIDTH_ATTR);
            if( width != null )
            {
                int oldWidth = Integer.parseInt(width);
                node.x += ( node.width - oldWidth ) / 2;
                node.width = oldWidth;
            }
            String height = node.getAttribute(OLD_HEIGHT_ATTR);
            if( height != null )
            {
                int oldHeight = Integer.parseInt(height);
                node.y += ( node.height - oldHeight ) / 2;
                node.height = oldHeight;
            }
        }
    }

    protected void smoothEdges(Graph graph)
    {
        Iterator<Edge> iter = graph.edgeIterator();
        while( iter.hasNext() )
        {
            Edge edge = iter.next();
            if (edge.fixed)
                continue;
            Path oldPath = edge.getPath();
            if( oldPath != null && oldPath.npoints > 2 )
            {
                Path newPath = new Path();
                newPath.addPoint(oldPath.xpoints[0], oldPath.ypoints[0], Path.LINE_TYPE);
                Point previous = new Point(oldPath.xpoints[0], oldPath.ypoints[0]);
                Point current = new Point(oldPath.xpoints[1], oldPath.ypoints[1]);
                for( int i = 2; i < oldPath.npoints; i++ )
                {
                    Point next = new Point(oldPath.xpoints[i], oldPath.ypoints[i]);

                    double d = Point.distance(previous.x, previous.y, current.x, current.y);
                    if( d > RADIUS )
                    {
                        int x = current.x + (int) ( (double) ( previous.x - current.x ) / 2 );
                        int y = current.y + (int) ( (double) ( previous.y - current.y ) / 2 );
                        newPath.addPoint(x, y, Path.LINE_TYPE);
                    }

                    newPath.addPoint(current.x, current.y, Path.QUAD_TYPE);

                    d = Point.distance(current.x, current.y, next.x, next.y);
                    if( d > RADIUS )
                    {
                        int x = current.x + (int) ( (double) ( next.x - current.x ) / 2 );
                        int y = current.y + (int) ( (double) ( next.y - current.y ) / 2 );
                        newPath.addPoint(x, y, Path.LINE_TYPE);
                        current.setLocation(x, y);
                    }

                    previous = current;
                    current = next;
                }
                newPath.addPoint(current.x, current.y, Path.LINE_TYPE);
                edge.setPath(newPath);
            }
        }
    }
}